{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/interopRequireDefault\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/classCallCheck\"","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/createClass\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/inherits\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-prototype-of\"","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/assign\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/map\"","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/keys\"","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/slicedToArray\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/set\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/get-iterator\"","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/get\"","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/external \"path\"","webpack://JavaScriptObfuscator/./src/cli/JavaScriptObfuscatorCLI.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen-wallaby\"","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/external \"fs\"","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/external \"pjson\"","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/freeze\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/array/from\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/typeof\"","webpack://JavaScriptObfuscator/./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/external \"multimatch\"","webpack://JavaScriptObfuscator/./src/cli/utils/SourceCodeReader.ts","webpack://JavaScriptObfuscator/./src/cli/utils sync","webpack://JavaScriptObfuscator/external \"mkdirp\"","webpack://JavaScriptObfuscator/./src/cli/utils/CLIUtils.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/SourceMapModeSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/BooleanSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ArraySanitizer.ts","webpack://JavaScriptObfuscator/external \"commander\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/source-map/SourceMapCorrector.ts","webpack://JavaScriptObfuscator/./src/SourceCode.ts","webpack://JavaScriptObfuscator/./src/ObfuscationResult.ts","webpack://JavaScriptObfuscator/external \"events\"","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/enums/JSFuck.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/has-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/define-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-names\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/get-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-descriptor\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/define-property\"","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","require","ServiceIdentifiers","NodeType_1","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","ContinueStatement","ExportNamedDeclaration","ExpressionStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isBlockStatementNode","nodesWithBlockScope","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isIdentifierNode","parentNodeIsPropertyNode","isPropertyNode","computed","key","parentNodeIsMemberExpressionNode","isMemberExpressionNode","parentNodeIsMethodDefinitionNode","isMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","directive","VariableDeclaration","VariableDeclarator","WhileStatement","escodegen","__importStar","espree","estraverse","NodeGuards_1","NodeMetadata_1","NodeUtils","isLiteralNode","content","raw","precedence","Precedence","Primary","astTree","parentize","cloneRecursive","code","structure","parse","sourceType","replace","enter","parentizeNode","addXVerbatimPropertyToLiteralNode","NodeMetadata","set","ignoredNode","body","reduce","generate","sourceMapWithCode","targetNode","getBlockScopesOfNodeRecursive","getSiblingStatementNodeByOffset","ReferenceError","isNodeHasScope","getScopeOfNode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","_keys","default","forEach","clonedValue","RegExp","Array","isArray","map","_typeof2","blockScopes","arguments","length","depth","push","isNodeHasBlockScope","offset","scopeNode","scopeBody","consequent","indexOf","defaultDescriptor","initializedTargetMetadataKey","initializablePropertiesSetMetadataKey","wrappedMethodsSetMetadataKey","constructorMethodName","initializeTargetMetadata","metadataKey","metadataValue","target","_hasMetadata","_defineMetadata","initializable","initializeMethodName","decoratorName","this","propertyKey","initializeMethod","Error","concat","_set","ownPropertyNames","_getOwnPropertyNames","prohibitedPropertyNames","propertyName","initializablePropertiesSet","_getMetadata","wrappedMethodsSet","isProhibitedPropertyName","has","targetProperty","methodDescriptor","_getOwnPropertyDescriptor","originalMethod","_defineProperty","_assign","apply","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","propertyDescriptor","newVal","wrapInitializableProperty","TransformationStage","inversify_1","ServiceIdentifiers_1","Initializable_1","AbstractNodeTransformer","randomGenerator","options","nodeIdentifier","getRandomInteger","tslib_1","__decorate","__metadata","Number","postConstruct","Function","injectable","__param","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","AssignmentExpression","BinaryExpression","breakStatementNode","callee","args","continueStatementNode","expression","functionName","params","id","identifierNode","generator","test","alternate","x-verbatim-property","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","GlobalVariableTemplate1_1","GlobalVariableTemplate2_1","AbstractCustomNode","AbstractCustomNode_1","identifierNamesGeneratorFactory","cachedNode","identifierNamesGenerator","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","literalNode","IdentifierObfuscatingReplacer","ObfuscationTarget","ControlFlowCustomNode","ObfuscationEvent","NodeAppender","scopeStatements","parentizeScopeStatementsBeforeAppend","setScopeNodeStatements","_toConsumableArray2","getScopeNodeStatements","blockScopeStackTraceData","blockScopeNode","nodeBodyStatements","targetBlockScope","index","getOptimalBlockScope","prependNode","blockScopeTraceData","deep","Infinity","firstCall","stackTrace","targetStatement","indexInScopeStatement","insertNodeAtIndex","slice","statement","statements","AnalyzersModule_1","ControlFlowTransformersModule_1","ConvertingTransformersModule_1","CustomNodesModule_1","FinalizingTransformersModule_1","GeneratorsModule_1","NodeTransformersModule_1","ObfuscatingTransformersModule_1","OptionsModule_1","PreparingTransformersModule_1","StoragesModule_1","UtilsModule_1","JavaScriptObfuscator_1","Logger_1","ObfuscationEventEmitter_1","ObfuscationResult_1","SourceCode_1","SourceMapCorrector_1","TransformersRunner_1","InversifyContainerFacade","container","Container","serviceIdentifier","named","getNamed","sourceCode","bind","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscationResult","ObfuscationResult","Factory__IObfuscationResult","toFactory","context","obfuscatedCode","sourceMap","obfuscationResult","initialize","ISourceMapCorrector","SourceMapCorrector","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","bindingName","cache","_map","dependencies","_key","cachedDependencies","dependency","constructor","JSFuck_1","Utils","dec","toString","url","split","number","string","times","substring","_from","character","JSFuck","join","hexadecimalPrefix","CustomNode","NodeTransformer","InversifyContainerFacade_1","JavaScriptObfuscatorCLI_1","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","obfuscate","unload","argv","javaScriptObfuscatorCLI","JavaScriptObfuscatorCLI","run","StringArrayEncoding","SourceMapMode","IdentifierNamesGenerator","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","stackTraceLength","Math","max","round","AbstractObfuscatingReplacer","IdentifierNamesGenerator_1","ObfuscationTarget_1","SourceMapMode_1","NO_ADDITIONAL_NODES_PRESET","_freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","HexadecimalIdentifierNamesGenerator","identifiersPrefix","log","renameGlobals","reservedNames","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","Separate","stringArray","stringArrayEncoding","stringArrayThreshold","Browser","transformObjectKeys","unicodeEscapeSequence","commander","packageJson","path","Default_1","ArraySanitizer_1","BooleanSanitizer_1","IdentifierNamesGeneratorSanitizer_1","ObfuscatingTargetSanitizer_1","SourceMapModeSanitizer_1","StringArrayEncodingSanitizer_1","CLIUtils_1","JavaScriptObfuscatorFacade_1","SourceCodeReader_1","rawArguments","inputPath","normalize","commands","Command","configureCommands","configureHelp","inputCLIOptions","opts","outputHelp","sourceCodeData","SourceCodeReader","readSourceCode","processSourceCodeData","filterOptions","configFilePath","config","configFileLocation","resolve","configFileOptions","CLIUtils","getUserConfig","DEFAULT_PRESET","usage","version","option","BooleanSanitizer","parseFloat","ArraySanitizer","IdentifierNamesGeneratorSanitizer","SourceMapModeSanitizer","StringArrayEncodingSanitizer","ObfuscationTargetSanitizer","on","console","outputPath","output","_ref","filePath","outputCodePath","getOutputCodePath","_this","processSourceCode","sourceCodeIndex","buildOptions","baseIdentifiersPrefix","processSourceCodeWithSourceMap","processSourceCodeWithoutSourceMap","filteredOptions","getObfuscatedCode","writeFile","outputSourceMapPath","getOutputSourceMapPath","basename","getSourceMap","encoding","obfuscatedFilePrefix","String","GlobalVariableNoEvalTemplate","AbstractControlFlowReplacer","AbstractControlFlowReplacer_1","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","controlFlowStorage","replacerId","usingExistingIdentifierChance","controlFlowStorageId","getStorageId","storageKeysById","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","storageKey","generateStorageKey","getRandomString","getStorage","identifierDataByControlFlowStorageId","Factory__IControlFlowCustomNode","AbstractCalleeDataExtractor","_classCallCheck2","LoggingPrefix","chalk_1","__importDefault","LoggingPrefix_1","loggingMessage","colorInfo","Base","colorSuccess","colorWarn","loggingLevelColor","loggingPrefix","processedMessage","cyan","green","yellow","md5_1","chance_1","RandomGenerator","RandomGenerator_1","min","md5Hash","floor","random","Chance","getSourceCode","floating","fixed","integer","pool","randomGeneratorPool","MapStorage","storage","storageId","_step","_iterator","_getIterator2","_iteratorNormalCompletion","next","done","_step$value","_slicedToArray2","size","mergeId","ObfuscatingGuard","LiteralObfuscatingReplacer","AbstractIdentifierNamesGenerator","identifierName","some","reservedName","exec","CustomNodeGroup","DeadCodeInjectionCustomNode","ControlFlowCustomNode_1","ExpressionWithOperatorControlFlowReplacer","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","ControlFlowReplacer","CalleeDataExtractor","fs","multimatch_1","isFilePath","isValidFile","readFile","isDirectoryPath","isValidDirectory","readDirectoryRecursive","availableFilePaths","availableInputExtensions","extension","directoryPath","fileData","readdirSync","fileName","logFilePath","readFileSync","isExcludedPath","extname","excludePatterns","isExcludedFilePathByGlobPattern","excludePattern","statSync","isDirectory","_a","isFile","normalizedFilePath","CLI","webpackEmptyContext","req","e","keys","mkdirp","lastIndexOf","configPath","_b","data","sync","dirname","writeFileSync","StringArrayEncoding_1","Base64","Rc4","SyntaxError","trim","VisitorDirection","VisitorDirection_1","nodeTransformerFactory","nodeTransformers","transformationStage","visitor","enterVisitors","leaveVisitors","nodeTransformersLength","getVisitor","leave","mergeVisitorsForDirection","Enter","Leave","visitors","direction","visitorsLength","isIgnoredNode","VisitorOption","Skip","visitorFunction","visitorResult","isNode","Factory__INodeTransformer","obfuscationResultFactory","cryptUtils","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","Inline","btoa","ICryptUtils","events_1","decorate","EventEmitter","EspreeFacade","input","sourceTypeLength","sourceTypes","parseType","error","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","red","LoggingMessage","LoggingMessage_1","NodeTransformer_1","TransformationStage_1","EspreeFacade_1","transformersRunner","sourceMapCorrector","logger","timeStart","Date","now","info","Version","ObfuscationStarted","RandomGeneratorSeed","getSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","getObfuscationResult","espreeParseOptions","runTransformationStage","Preparing","DeadCodeInjection","ControlFlowFlattening","Converting","Obfuscating","Finalizing","warn","EmptySourceCode","escodegenParams","sourceContent","format","correct","transform","transformersList","attachComment","comment","ecmaFeatures","experimentalObjectRestSpread","ecmaVersion","loc","range","verbatim","BlockStatementControlFlowTransformer","ClassDeclarationTransformer","CommentsTransformer","CustomNodesTransformer","DeadCodeInjectionTransformer","EvalCallExpressionTransformer","FunctionControlFlowTransformer","CatchClauseTransformer","FunctionDeclarationTransformer","FunctionTransformer","ImportDeclarationTransformer","LabeledStatementTransformer","LiteralTransformer","MemberExpressionTransformer","MetadataTransformer","MethodDefinitionTransformer","ObfuscatingGuardsTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","ParentificationTransformer","TemplateLiteralTransformer","VariableDeclarationTransformer","EscapeSequenceEncoder","stringsCache","encodeAllSymbols","cacheKey","template","replaceRegExp","escapeSequenceRegExp","regExp","charCodeAt","Utils_1","CryptUtils","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charAt","str","randomStringDiff","randomStringDiffArray","shuffle","s1","s2","i1","i2","randomMerge","x","j","y","ArrayUtils","array","temp","newArray","pop","unshift","shuffledArray","ArrayUtils_1","CryptUtils_1","EscapeSequenceEncoder_1","ContainerModule","IArrayUtils","IEscapeSequenceEncoder","ArrayStorage","storageLength","splice","ArrayStorage_1","StringArrayStorage","StringArrayStorage_1","arrayUtils","_possibleConstructorReturn2","__proto__","_getPrototypeOf","_get2","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","stringArrayName","stringArrayCallsWrapperName","rotationValue","arrayRotate","CustomNodeGroup_1","MapStorage_1","CustomNodeGroupStorage","CustomNodeGroupStorage_1","customNodeGroupFactory","customNodeGroupsList","customNodeGroupName","customNodeGroup","_this2","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNodeGroup","ControlFlowStorage","ControlFlowStorage_1","TCustomNodeGroupStorage","TStringArrayStorage","Newable__TControlFlowStorage","toConstructor","Factory__TControlFlowStorage","AbstractNodeTransformer_1","NodeUtils_1","transformNode","ObfuscatingGuard_1","ObfuscatingGuardsTransformer_1","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","obfuscationAllowed","every","nodeGuard","check","BlackListNodeGuard","ConditionalCommentNodeGuard","Factory__INodeGuard","renamedIdentifier","replacedLiteral","js_string_escape_1","NodeFactory_1","EvalCallExpressionTransformer_1","evalRootAstHostNodeSet","isCallExpressionNode","isEvalRootAstHostNode","restoreNode","callExpressionNode","callExpressionFirstArgument","ast","evalString","extractEvalStringFromCallExpressionArgument","convertCodeToStructure","evalRootAstHostNode","functionExpressionNode","blockStatementNode","targetAst","convertStructureToCode","isFunctionExpressionNode","extractEvalStringFromLiteralNode","isTemplateLiteralNode","extractEvalStringFromTemplateLiteralNode","quasis","expressions","cooked","ObfuscationEvent_1","stackTraceAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","stackTraceData","analyzeNode","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","_this3","once","getAppendEvent","appendCustomNodes","emit","BeforeObfuscation","AfterObfuscation","IStackTraceAnalyzer","ConditionalCommentObfuscatingGuard","ConditionalCommentObfuscatingGuard_1","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","isNodeWithComments","checkComments","comments","commentsLength","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","CommentsTransformer_1","transformComments","filter","preservedWords","preservedWord","BlackListObfuscatingGuard","BlackListObfuscatingGuard_1","blackListGuardsLength","blackListGuards","isUseStrictOperator","CustomNodesTransformer_1","EvaCallExpressionTransformer_1","MetadataTransformer_1","ParentificationTransformer_1","INodeTransformer","whenTargetNamed","INodeGuard","getCacheFactory","StringArrayThresholdRule","StringArrayEncodingRule","StringArrayRule","SourceMapFileNameRule","SourceMapBaseUrlRule","endsWith","SelfDefendingRule","DomainLockRule","normalizedDomains","domain","extractDomainFromUrl","DeadCodeInjectionThresholdRule","DeadCodeInjectionRule","ControlFlowFlatteningThresholdRule","ControlFlowFlatteningThresholdRule_1","DeadCodeInjectionRule_1","DeadCodeInjectionThresholdRule_1","DomainLockRule_1","SelfDefendingRule_1","SourceMapBaseUrlRule_1","SourceMapFileNameRule_1","StringArrayRule_1","StringArrayEncodingRule_1","StringArrayThresholdRule_1","OptionsNormalizer","OptionsNormalizer_1","normalizedOptions","normalizerRules","normalizerRule","ValidationErrorsFormatter","validationErrors","errorsArray","formatError","validationError","constraints","errorString","constraint","class_validator_1","ValidationErrorsFormatter_1","Options","Options_1","optionsNormalizer","errors","validateSync","validatorOptions","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","MangledIdentifierNamesGenerator","ValidateIf","IsUrl","require_protocol","require_tld","require_valid_protocol","BrowserNoEval","Node","IOptionsNormalizer","IdentifierObfuscatingReplacer_1","identifierObfuscatingReplacerFactory","replaceableIdentifiers","identifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","isVariableDeclarationNode","isExportNamedDeclarationNode","variableDeclarationNode","getBlockScopesOfNode","isGlobalDeclaration","storeVariableNames","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","traverseDeclarationIdentifiers","storeGlobalName","storeLocalName","cachedReplaceableIdentifiersNamesMap","identifierNames","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","_this4","storedReplaceableIdentifiersNamesMap","isReplaceableIdentifierNode","isRenamedIdentifier","newIdentifierName","_this5","storedReplaceableIdentifiers","declarationNode","traverse","Factory__IIdentifierObfuscatingReplacer","AbstractObfuscatingReplacer_1","StringLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer_1","stringArrayStorage","escapeSequenceEncoder","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","nodeValue","useStringArray","canUseStringArray","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","decToHex","hexadecimalIndex","encodedValue","rc4","encode","_getEncodedValue","getEncodedValue","escapedValue","getLength","stringArrayStorageCallsWrapperName","getStringArrayHexadecimalIndex","_getStringArrayHexade","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","hexadecimalLiteralNode","literalValue","rc4KeyLiteralNode","NumberLiteralObfuscatingReplacer","numberLiteralCache","rawValue","isCeilNumber","LiteralObfuscatingReplacer_1","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","BooleanLiteralObfuscatingReplacer","isImportDeclarationNode","Factory__IObfuscatingReplacer","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","ImportDeclarationTransformer_1","importDeclarationNode","storeImportSpecifierNames","specifiers","importSpecifierNode","isProhibitedImportSpecifierNode","local","isImportSpecifierNode","imported","isFunctionDeclarationNode","isArrowFunctionExpressionNode","functionNode","storeFunctionParams","replaceFunctionParams","paramsNode","isAssignmentPatternNode","ignoredIdentifierNamesSet","replaceVisitor","isObjectPatternNode","addIdentifiersToIgnoredIdentifierNamesSet","functionDeclarationNode","storeFunctionName","isClassDeclarationNode","classDeclarationNode","storeClassName","isCatchClauseNode","catchClauseNode","storeCatchClauseParam","replaceCatchClauseParam","param","BooleanLiteralObfuscatingReplacer_1","getTrueUnaryExpressionNode","getFalseUnaryExpressionNode","arrayExpressionNode","namesMap","mapKey","nodeName","isReservedName","generateWithPrefix","BaseIdentifierObfuscatingReplacer_1","CatchClauseTransformer_1","ClassDeclarationTransformer_1","FunctionDeclarationTransformer_1","FunctionTransformer_1","LabeledStatementTransformer_1","LiteralTransformer_1","NumberLiteralObfuscatingReplacer_1","VariableDeclarationTransformer_1","IObfuscatingReplacer","IIdentifierObfuscatingReplacer","AbstractIdentifierNamesGenerator_1","MangledIdentifierNamesGenerator_1","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","nameSequence","nameLength","zeroSequence","num","repeat","indexInSequence","newMangledName","isValidIdentifierName","HexadecimalIdentifierNamesGenerator_1","randomVariableNameSet","randomInteger","baseIdentifierName","substr","baseIdentifierNameLength","IIdentifierNamesGenerator","cachedIdentifierNamesGenerator","StringLiteralNode","expressionStatementNode","StringLiteralControlFlowStorageCallNode","controlFlowStorageName","controlFlowStorageKey","memberExpressionNode","StringArrayRotateFunctionTemplate","SelfDefendingTemplate","string_template_1","NoCustomNodes_1","SelfDefendingTemplate_1","StringArrayRotateFunctionTemplate_1","StringArrayRotateFunctionNode","stringArrayRotateValue","getTemplate","timesName","whileFunctionName","StringArrayTemplate","StringArrayTemplate_1","StringArrayNode","rotateArray","StringArrayRc4DecodeNodeTemplate","initializedIdentifier","rc4Identifier","dataIdentifier","onceIdentifier","StringArrayCallsWrapperTemplate","StringArrayBase64DecodeNodeTemplate","base64DecodeFunctionIdentifier","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","Rc4Template","AtobTemplate","AtobTemplate_1","GlobalVariableNoEvalTemplate_1","Rc4Template_1","StringArrayBase64DecodeNodeTemplate_1","StringArrayCallsWrapperTemplate_1","StringArrayRC4DecodeNodeTemplate_1","StringArrayCallsWrapper","decodeNodeTemplate","getDecodeStringArrayTemplate","globalVariableTemplate","getGlobalVariableTemplate","atobPolyfill","decodeStringArrayTemplate","selfDefendingCode","rc4Polyfill","SelfDefendingUnicodeNode","callsControllerFunctionName","selfDefendingFunctionName","singleNodeCallControllerFunctionName","SingleNodeCallControllerTemplate","SingleNodeCallControllerTemplate_1","NodeCallsControllerFunctionNode","LogicalExpressionFunctionNode","returnStatementNode","logicalExpressionNode","leftValue","rightValue","DomainLockNodeTemplate","DomainLockNodeTemplate_1","DomainLockNode","domainsString","hideString","hiddenDomainsString","_cryptUtils$hideStrin2","diff","domainLockFunctionName","domains","DebugProtectionFunctionTemplate","DebuggerTemplateNoEval","DebuggerTemplate","DebuggerTemplate_1","DebuggerTemplateNoEval_1","DebugProtectionFunctionTemplate_1","DebugProtectionFunctionNode","debugProtectionFunctionName","debuggerTemplate","DebugProtectionFunctionIntervalTemplate","DebugProtectionFunctionIntervalTemplate_1","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionCallTemplate_1","DebugProtectionFunctionCallNode","ConsoleOutputDisableExpressionTemplate","ConsoleOutputDisableExpressionTemplate_1","ConsoleOutputDisableExpressionNode","consoleLogDisableFunctionName","ControlFlowStorageNode","propertyNodes","_ref2","propertyNode","variableDeclaratorNode","objectExpressionNode","CallExpressionFunctionNode","expressionArguments","calleeIdentifier","argumentsLength","CallExpressionControlFlowStorageCallNode","BlockStatementDeadCodeInjectionNode","deadCodeInjectionRootAstHostNode","random1","random2","leftString","rightString","ifStatementNode","binaryExpressionNode","BlockStatementControlFlowFlatteningNode","blockStatementBody","shuffledKeys","originalKeysIndexesInShuffledArray","controllerIdentifierName","indexIdentifierName","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","BinaryExpressionFunctionNode","CustomNode_1","AbstractCustomNodeGroup_1","NodeAppender_1","customNodeFactory","appendCustomNodeIfExist","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","_stringArrayStorageId2","Factory__ICustomNode","randomStackTraceIndex","getRandomStackTraceIndex","appendNodeToOptimalBlockScope","selfDefendingUnicodeNode","nodeCallsControllerFunctionNode","domainLockNode","appendNode","programBodyLength","randomIndex","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","consoleOutputDisableExpressionNode","DeadCodeInjectionCustomNode_1","ConsoleOutputCustomNodeGroup_1","DebugProtectionCustomNodeGroup_1","DomainLockCustomNodeGroup_1","SelfDefendingCustomNodeGroup_1","StringArrayCustomNodeGroup_1","BinaryExpressionFunctionNode_1","BlockStatementControlFlowFlatteningNode_1","BlockStatementDeadCodeInjectionNode_1","CallExpressionControlFlowStorageCallNode_1","CallExpressionFunctionNode_1","ControlFlowStorageNode_1","ConsoleOutputDisableExpressionNode_1","DebugProtectionFunctionCallNode_1","DebugProtectionFunctionIntervalNode_1","DebugProtectionFunctionNode_1","DomainLockNode_1","ExpressionWithOperatorControlFlowStorageCallNode_1","LogicalExpressionFunctionNode_1","NodeCallsControllerFunctionNode_1","SelfDefendingUnicodeNode_1","StringArrayCallsWrapper_1","StringArrayNode_1","StringArrayRotateFunctionNode_1","StringLiteralControlFlowStorageCallNode_1","StringLiteralNode_1","ICustomNode","Newable__ICustomNode","ICustomNodeGroup","getFactory","getConstructorFactory","Factory__IDeadCodeInjectionCustomNode","TemplateLiteralTransformer_1","isValidTemplateLiteralNode","templateLiteralNode","templateLiteralExpressions","nodes","templateElement","shift","isLiteralNodeWithStringValue","root","isTaggedTemplateExpressionNode","isObjectExpressionNode","ObjectExpressionKeysTransformer_1","cachedScopeNodesMap","isVariableDeclaratorNode","variableDeclarator","transformObjectExpressionNode","memberExpressionObject","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isValidPropertyValueNode","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","assignmentExpressionNode","memberExpressionObjectNode","extractPropertiesToExpressionStatements","_extractPropertiesToE2","filterObjectExpressionProperties","appendExpressionStatements","variableDeclaration","insertNodeAfter","propertyKeyNode","propertyValueNode","isArrayPatternNode","isRestElementNode","MethodDefinitionTransformer_1","methodDefinitionNode","ignoredNames","MemberExpressionTransformer_1","ObjectExpressionTransformer_1","StringLiteralControlFlowReplacer","StringLiteralControlFlowReplacer_1","literalFunctionCustomNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","ExpressionWithOperatorControlFlowReplacer_1","LogicalExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer_1","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","expressionNode","nodeForCheck","ControlFlowReplacer_1","FunctionControlFlowTransformer_1","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","hostNode","getHostNode","getControlFlowStorage","transformFunctionBody","controlFlowStorageCustomNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","Factory__IControlFlowReplacer","DeadCodeInjectionTransformer_1","deadCodeInjectionCustomNodeFactory","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","isDeadCodeInjectionRootAstHostNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformersToRenameBlockScopeIdentifiers","minCollectedBlockStatementsCount","Break","isValidWrappedBlockStatementNode","maxInteger","randomBlockStatementNode","replaceBlockStatementNode","hostNodeFirstStatement","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","newBlockStatementNode","isAwaitExpressionNode","isSuperNode","indexInScope","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","CallExpressionControlFlowReplacer_1","callExpressionFunctionCustomNode","BlockStatementControlFlowTransformer_1","canTransformBlockStatementNode","originalKeys","arrayRange","arrayShuffle","blockStatementControlFlowFlatteningCustomNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isClassDeclaration","canTransform","isWhileStatementNode","blockStatementHasProhibitedStatements","BinaryExpressionControlFlowReplacer_1","binaryExpressionFunctionCustomNode","IControlFlowReplacer","CalleeDataExtractor_1","StackTraceAnalyzer","StackTraceAnalyzer_1","calleeDataExtractorFactory","analyzeRecursive","blockScopeBody","limitIndex","getLimitIndex","blockScopeBodyLength","blockScopeBodyNode","analyzeCallExpressionNode","_loop","calleeDataExtractorsList","calleeDataExtractorName","calleeData","extract","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitThreshold","FunctionDeclarationCalleeDataExtractor","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","AbstractCalleeDataExtractor_1","ObjectExpressionCalleeDataExtractor_1","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","calleeBlockStatement","getCalleeBlockStatement","currentChain","memberExpression","objectName","findCalleeBlockStatement","objectExpressionProperties","nextItemInCallsChain","isValidTargetPropertyNode","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","FunctionDeclarationCalleeDataExtractor_1","FunctionExpressionCalleeDataExtractor_1","ICalleeDataExtractor"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 219);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"inversify\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscationResult = 'Factory<IObfuscationResult>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscationResult = 'IObfuscationResult',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","module.exports = require(\"tslib\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/core-js/object/get-prototype-of\");","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithBlockScope: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDefaultSpecifierNode (node: ESTree.Node): node is ESTree.ImportDefaultSpecifier {\n        return node.type === NodeType.ImportDefaultSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportNamespaceSpecifierNode (node: ESTree.Node): node is ESTree.ImportNamespaceSpecifier {\n        return node.type === NodeType.ImportNamespaceSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeHasBlockScope (node: ESTree.Node, parentNode: ESTree.Node): node is TNodeWithBlockScope {\n        return NodeGuards.isProgramNode(node) || (\n            NodeGuards.isBlockStatementNode(node)\n            && NodeGuards.nodesWithBlockScope.includes(parentNode.type)\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeHasScope (node: ESTree.Node): node is TNodeWithScope {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!NodeGuards.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = NodeGuards.isPropertyNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            NodeGuards.isMemberExpressionNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.property === node\n        );\n        const parentNodeIsMethodDefinitionNode: boolean = NodeGuards.isMethodDefinitionNode(parentNode) &&\n            !parentNode.computed;\n        const isLabelIdentifierNode: boolean = NodeGuards.isLabelIdentifierNode(node, parentNode);\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !parentNodeIsMethodDefinitionNode &&\n            !isLabelIdentifierNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","import * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { TObject } from '../types/TObject';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyToLiteralNode <T extends ESTree.Node = ESTree.Node> (node: T): T {\n        if (NodeGuards.isLiteralNode(node)) {\n            node['x-verbatim-property'] = {\n                content: node.raw,\n                precedence: escodegen.Precedence.Primary\n            };\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentize(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, { sourceType: 'script' });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n                NodeUtils.addXVerbatimPropertyToLiteralNode(node);\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {TNodeWithBlockScope[]}\n     */\n    public static getBlockScopesOfNode (targetNode: ESTree.Node): TNodeWithBlockScope[] {\n        return NodeUtils.getBlockScopesOfNodeRecursive(targetNode);\n    }\n\n    /**\n     * @param {Statement} node\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatementNode (node: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementNodeByOffset(node, 1);\n    }\n\n    /**\n     * @param {Statement} node\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatementNode (node: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementNodeByOffset(node, -1);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithScope}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithScope {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeHasScope(parentNode)) {\n            return NodeUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentize <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: TObject = {};\n\n        Object\n            .keys(node)\n            .forEach((property: string) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[<keyof T>property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = clonedValue;\n            });\n\n        return <T>copy;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {TNodeWithBlockScope[]} blockScopes\n     * @param {number} depth\n     * @returns {TNodeWithBlockScope[]}\n     */\n    private static getBlockScopesOfNodeRecursive (\n        node: ESTree.Node,\n        blockScopes: TNodeWithBlockScope[] = [],\n        depth: number = 0\n    ): TNodeWithBlockScope[] {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        /**\n         * Stage 1: process root block statement node of the slice of AST-tree\n         */\n        if (NodeGuards.isBlockStatementNode(node) && parentNode === node) {\n            blockScopes.push(node);\n        }\n\n        /**\n         * Stage 2: process any other nodes\n         */\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            /**\n             * we shouldn't add to the array input node that is node with block scope itself\n             * so, on depth 0 we will skip push to the array of block scopes\n             */\n            (depth && NodeGuards.isNodeHasBlockScope(node, parentNode))\n        ) {\n            blockScopes.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeUtils.getBlockScopesOfNodeRecursive(parentNode, blockScopes, ++depth);\n        }\n\n        return blockScopes;\n    }\n\n    /**\n     * @param {Statement} node\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementNodeByOffset (node: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(node);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(node);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","module.exports = require(\"@babel/runtime/core-js/object/assign\");","export enum TransformationStage {\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer, IInitializable {\n    /**\n     * @type {number}\n     */\n    @initializable()\n    protected nodeIdentifier!: number;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.nodeIdentifier = this.randomGenerator.getRandomInteger(0, 10000);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        const breakStatementNode: ESTree.BreakStatement = {\n            type: NodeType.BreakStatement,\n            metadata: { ignoredNode: false }\n        };\n\n        if (label) {\n            breakStatementNode.label = label;\n        }\n\n        return breakStatementNode;\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        const continueStatementNode: ESTree.ContinueStatement = {\n            type: NodeType.ContinueStatement,\n            metadata: { ignoredNode: false }\n        };\n\n        if (label) {\n            continueStatementNode.label = label;\n        }\n\n        return continueStatementNode;\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {any[]} args\n     */\n    public abstract initialize (...args: any[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n","module.exports = require(\"@babel/runtime/core-js/map\");","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","module.exports = require(\"string-template\");","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","export enum ObfuscationTarget {\n    Browser = 'browser',\n    BrowserNoEval = 'browser-no-eval',\n    Node = 'node'\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     */\n    public static appendNode (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...NodeAppender.getScopeNodeStatements(scopeNode),\n            ...scopeStatements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} blockScopeStackTraceData\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {TStatement[]} nodeBodyStatements\n     * @param {number} index\n     */\n    public static appendNodeToOptimalBlockScope (\n        blockScopeStackTraceData: IStackTraceData[],\n        blockScopeNode: TNodeWithBlockScope,\n        nodeBodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        let targetBlockScope: TNodeWithBlockScope;\n\n        if (!blockScopeStackTraceData.length) {\n            targetBlockScope = blockScopeNode;\n        } else {\n            targetBlockScope = NodeAppender.getOptimalBlockScope(\n                blockScopeStackTraceData,\n                index\n            );\n        }\n\n        NodeAppender.prependNode(targetBlockScope, nodeBodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} blockScopeTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        blockScopeTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = blockScopeTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @param {Node} targetStatement\n     */\n    public static insertNodeAfter (scopeNode: TNodeWithScope, scopeStatements: TStatement[], targetStatement: ESTree.Statement): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeNodeStatements(scopeNode)\n            .indexOf(targetStatement);\n\n        NodeAppender.insertNodeAtIndex(scopeNode, scopeStatements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @param {number} index\n     */\n    public static insertNodeAtIndex (scopeNode: TNodeWithScope, scopeStatements: TStatement[], index: number): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...NodeAppender.getScopeNodeStatements(scopeNode).slice(0, index),\n            ...scopeStatements,\n            ...NodeAppender.getScopeNodeStatements(scopeNode).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     */\n    public static prependNode (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...scopeStatements,\n            ...NodeAppender.getScopeNodeStatements(scopeNode),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @returns {TStatement[]}\n     */\n    private static getScopeNodeStatements (scopeNode: TNodeWithScope): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(scopeNode)) {\n            return scopeNode.consequent;\n        }\n\n        return scopeNode.body;\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): TStatement[] {\n        scopeStatements.forEach((statement: TStatement) => {\n            statement.parentNode = scopeNode;\n        });\n\n        return scopeStatements;\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} statements\n     */\n    private static setScopeNodeStatements (scopeNode: TNodeWithScope, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(scopeNode)) {\n            scopeNode.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        scopeNode.body = statements;\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/keys\");","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { ISourceCode } from '../interfaces/ISourceCode';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscationResult } from '../ObfuscationResult';\nimport { SourceCode } from '../SourceCode';\nimport { SourceMapCorrector } from '../source-map/SourceMapCorrector';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult)\n            .to(ObfuscationResult)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.Factory__IObfuscationResult)\n            .toFactory<IObfuscationResult>((context: interfaces.Context) => {\n                return (obfuscatedCode: string, sourceMap: string) => {\n                    const obfuscationResult: IObfuscationResult = context.container\n                        .get<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult);\n\n                    obfuscationResult.initialize(obfuscatedCode, sourceMap);\n\n                    return obfuscationResult;\n                };\n            });\n\n        this.container\n            .bind<ISourceMapCorrector>(ServiceIdentifiers.ISourceMapCorrector)\n            .to(SourceMapCorrector)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","import { JSFuck } from '../enums/JSFuck';\n\nexport class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static decToHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFromUrl (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeilNumber (number: number): boolean {\n        return number % 1 === 0;\n    }\n\n    /**\n     * @param {string} string\n     * @param {number} times\n     * @returns {string}\n     */\n    public static stringRotate (string: string, times: number): string {\n        if (!string) {\n            throw new ReferenceError(`Cannot rotate empty string.`);\n        }\n\n        for (let i: number = 0; i < times; i++) {\n            string = string[string.length - 1] + string.substring(0, string.length - 1);\n        }\n\n        return string;\n    }\n\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public static stringToJSFuck (string: string): string {\n        return Array\n            .from(string)\n            .map((character: string): string => {\n                return JSFuck[<keyof typeof JSFuck>character] || character;\n            })\n            .join(' + ');\n    }\n}\n","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","module.exports = require(\"@babel/runtime/core-js/set\");","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer'\n}\n","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscationResult}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscationResult {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscationResult: IObfuscationResult = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscationResult;\n    }\n\n    /**\n     * @param {string[]} argv\n     */\n    public static runCLI (argv: string[]): void {\n        const javaScriptObfuscatorCLI: JavaScriptObfuscatorCLI = new JavaScriptObfuscatorCLI(argv);\n\n        javaScriptObfuscatorCLI.initialize();\n        javaScriptObfuscatorCLI.run();\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/get-iterator\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral['value']} nodeValue\n     * @param {number} nodeIdentifier\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], nodeIdentifier?: number): ESTree.Node;\n}\n","module.exports = require(\"@babel/runtime/helpers/get\");","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"path\");","import * as commander from 'commander';\nimport * as packageJson from 'pjson';\nimport * as path from 'path';\n\nimport { TInputCLIOptions } from '../types/options/TInputCLIOptions';\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TSourceCodeData } from '../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../interfaces/cli/IFileData';\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { ArraySanitizer } from './sanitizers/ArraySanitizer';\nimport { BooleanSanitizer } from './sanitizers/BooleanSanitizer';\nimport { IdentifierNamesGeneratorSanitizer } from './sanitizers/IdentifierNamesGeneratorSanitizer';\nimport { ObfuscationTargetSanitizer } from './sanitizers/ObfuscatingTargetSanitizer';\nimport { SourceMapModeSanitizer } from './sanitizers/SourceMapModeSanitizer';\nimport { StringArrayEncodingSanitizer } from './sanitizers/StringArrayEncodingSanitizer';\n\nimport { CLIUtils } from './utils/CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscatorFacade';\nimport { SourceCodeReader } from './utils/SourceCodeReader';\n\nexport class JavaScriptObfuscatorCLI implements IInitializable {\n    /**\n     * @type {BufferEncoding}\n     */\n    public static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @type {string}\n     */\n    public static obfuscatedFilePrefix: string = '-obfuscated';\n\n    /**\n     * @type {string}\n     */\n    private static readonly baseIdentifiersPrefix: string = 'a';\n\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rawArguments: string[];\n\n    /**\n     * @type {commander.CommanderStatic}\n     */\n    @initializable()\n    private commands!: commander.CommanderStatic;\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    @initializable()\n    private inputCLIOptions!: TInputCLIOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private inputPath!: string;\n\n    /**\n     * @param {string[]} argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = argv.slice(2);\n    }\n\n    /**\n     * @param {TObject} options\n     * @returns {TInputOptions}\n     */\n    private static filterOptions (options: TInputCLIOptions): TInputOptions {\n        const filteredOptions: TInputOptions = {};\n\n        Object\n            .keys(options)\n            .forEach((option: keyof TInputCLIOptions) => {\n                if (options[option] === undefined) {\n                    return;\n                }\n\n                filteredOptions[option] = options[option];\n            });\n\n        return filteredOptions;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithoutSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(sourceCode, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscationResult: IObfuscationResult = JavaScriptObfuscator.obfuscate(sourceCode, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscationResult.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscationResult.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscationResult.getSourceMap());\n        }\n    }\n\n    public initialize (): void {\n        this.inputPath = path.normalize(this.arguments[0] || '');\n        this.commands = <commander.CommanderStatic>(new commander.Command());\n\n        this.configureCommands();\n        this.configureHelp();\n\n        this.inputCLIOptions = this.commands.opts();\n    }\n\n    public run (): void {\n        const canShowHelp: boolean = !this.arguments.length || this.arguments.includes('--help');\n\n        if (canShowHelp) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        const sourceCodeData: TSourceCodeData = new SourceCodeReader(this.inputCLIOptions)\n            .readSourceCode(this.inputPath);\n\n        this.processSourceCodeData(sourceCodeData);\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputCLIOptions: TInputOptions = JavaScriptObfuscatorCLI.filterOptions(this.inputCLIOptions);\n        const configFilePath: string | undefined = this.inputCLIOptions.config;\n        const configFileLocation: string = configFilePath ? path.resolve(configFilePath, '.') : '';\n        const configFileOptions: TInputOptions = configFileLocation ? CLIUtils.getUserConfig(configFileLocation) : {};\n\n        return {\n            ...DEFAULT_PRESET,\n            ...configFileOptions,\n            ...inputCLIOptions\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands\n            .usage('<inputPath> [options]')\n            .version(\n                packageJson.version,\n                '-v, --version'\n            )\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                BooleanSanitizer\n            )\n            .option(\n                '--config <boolean>',\n                'Name of js / json config file'\n            )\n            .option(\n                '--control-flow-flattening <boolean>',\n                'Enables control flow flattening',\n                BooleanSanitizer\n            )\n            .option(\n                '--control-flow-flattening-threshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--dead-code-injection <boolean>',\n                'Enables dead code injection',\n                BooleanSanitizer\n            )\n            .option(\n                '--dead-code-injection-threshold <number>',\n                'The probability that the dead code injection transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debug-protection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--debug-protection-interval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--disable-console-output <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                BooleanSanitizer\n            )\n            .option(\n                '--domain-lock <list> (comma separated, without whitespaces)',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--exclude <list> (comma separated, without whitespaces)',\n                'A filename or glob which indicates files to exclude from obfuscation',\n                ArraySanitizer\n            )\n            .option(\n                '--identifier-names-generator <string> [hexadecimal, mangled]', 'Sets identifier names generator (Default: hexadecimal)',\n                IdentifierNamesGeneratorSanitizer\n            )\n            .option(\n                '--identifiers-prefix <string>',\n                'Sets prefix for all global identifiers.'\n            )\n            .option(\n                '--log <boolean>', 'Enables logging of the information to the console',\n                BooleanSanitizer\n            )\n            .option(\n                '--reserved-names <list> (comma separated, without whitespaces)',\n                'Disables obfuscation and generation of identifiers, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--rename-globals <boolean>', 'Allows to enable obfuscation of global variable and function names with declaration.',\n                BooleanSanitizer\n            )\n            .option(\n                '--rotate-string-array <boolean>', 'Disable rotation of unicode array values during obfuscation',\n                BooleanSanitizer\n            )\n            .option(\n                '--seed <number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--self-defending <boolean>',\n                'Disables self-defending for obfuscated code',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map <boolean>',\n                'Enables source map generation',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map-base-url <string>',\n                'Sets base url to the source map import url when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-file-name <string>',\n                'Sets file name for output source map when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-mode <string> [inline, separate]',\n                'Specify source map output mode',\n                SourceMapModeSanitizer\n            )\n            .option(\n                '--string-array <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                BooleanSanitizer\n            )\n            .option(\n                '--string-array-encoding <string|boolean> [true, false, base64, rc4]',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed',\n                StringArrayEncodingSanitizer\n            )\n            .option(\n                '--string-array-threshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--target <string>',\n                'Allows to set target environment for obfuscated code.',\n                ObfuscationTargetSanitizer\n            )\n            .option(\n                '--transform-object-keys <boolean>',\n                'Enables transformation of object keys',\n                BooleanSanitizer\n            )\n            .option(\n                '--unicode-escape-sequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                BooleanSanitizer\n            )\n            .parse(this.rawArguments);\n    }\n\n    private configureHelp (): void {\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator input_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_file_name.js --output output_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_directory_name --compact true --self-defending false');\n            console.log('');\n        });\n    }\n\n    /**\n     * @param {TSourceCodeData} sourceCodeData\n     */\n    private processSourceCodeData (sourceCodeData: TSourceCodeData): void {\n        const outputPath: string = this.inputCLIOptions.output\n            ? path.normalize(this.inputCLIOptions.output)\n            : '';\n\n        if (!Array.isArray(sourceCodeData)) {\n            const outputCodePath: string = outputPath || CLIUtils.getOutputCodePath(this.inputPath);\n\n            this.processSourceCode(sourceCodeData, outputCodePath, null);\n        } else {\n            sourceCodeData.forEach(({ filePath, content }: IFileData, index: number) => {\n                const outputCodePath: string = outputPath\n                    ? path.join(outputPath, filePath)\n                    : CLIUtils.getOutputCodePath(filePath);\n\n                this.processSourceCode(content, outputCodePath, index);\n            });\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {number | null} sourceCodeIndex\n     */\n    private processSourceCode (\n        sourceCode: string,\n        outputCodePath: string,\n        sourceCodeIndex: number | null\n    ): void {\n        let options: TInputOptions = this.buildOptions();\n\n        if (sourceCodeIndex !== null) {\n            const baseIdentifiersPrefix: string = this.inputCLIOptions.identifiersPrefix\n                || JavaScriptObfuscatorCLI.baseIdentifiersPrefix;\n            const identifiersPrefix: string = `${baseIdentifiersPrefix}${sourceCodeIndex}`;\n\n            options = {\n                ...options,\n                identifiersPrefix\n            };\n        }\n\n        if (options.sourceMap) {\n            JavaScriptObfuscatorCLI.processSourceCodeWithSourceMap(sourceCode, outputCodePath, options);\n        } else {\n            JavaScriptObfuscatorCLI.processSourceCodeWithoutSourceMap(sourceCode, outputCodePath, options);\n        }\n    }\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen-wallaby\");","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","module.exports = require(\"fs\");","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","module.exports = require(\"chalk\");","module.exports = require(\"pjson\");","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomFloat (min: number, max: number): number {\n        return this.getRandomGenerator().floating({\n            min: min,\n            max: max,\n            fixed: 7\n        });\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public abstract generate (): string;\n\n    /**\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (): string;\n\n    /**\n     * @param {string} identifierName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (identifierName: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(identifierName) !== null\n            )\n            : true;\n\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/freeze\");","module.exports = require(\"@babel/runtime/core-js/array/from\");","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","module.exports = require(\"espree\");","module.exports = require(\"@babel/runtime/helpers/typeof\");","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","module.exports = require(\"multimatch\");","import * as fs from 'fs';\nimport * as path from 'path';\nimport multimatch from 'multimatch';\n\nimport { TInputCLIOptions } from '../../types/options/TInputCLIOptions';\nimport { TSourceCodeData } from '../../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../../interfaces/cli/IFileData';\n\nimport { LoggingPrefix } from '../../enums/logger/LoggingPrefix';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\nimport { Logger } from '../../logger/Logger';\n\nexport class SourceCodeReader {\n    /**\n     * @type {string[]}\n     */\n    public static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    private readonly options: TInputCLIOptions;\n\n    /**\n     * @param {TInputCLIOptions} options\n     */\n    constructor (options: TInputCLIOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param {string} filePath\n     * @param {string[]} excludePatterns\n     * @returns {boolean}\n     */\n    private static isExcludedPath (filePath: string, excludePatterns: string[] = []): boolean {\n        if (!excludePatterns.length) {\n            return false;\n        }\n\n        const fileName: string = path.basename(filePath);\n        const isExcludedFilePathByGlobPattern: boolean = !!multimatch([filePath], excludePatterns).length;\n        const isExcludedFilePathByInclusion: boolean = excludePatterns.some((excludePattern: string) =>\n            filePath.includes(excludePattern) || fileName.includes(excludePattern)\n        );\n\n        return isExcludedFilePathByInclusion || isExcludedFilePathByGlobPattern;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isDirectoryPath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isDirectory();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     */\n    private static logFilePath (filePath: string): void {\n        const normalizedFilePath: string = path.normalize(filePath);\n\n        Logger.log(\n            Logger.colorInfo,\n            LoggingPrefix.CLI,\n            `Obfuscating file: ${normalizedFilePath}...`\n        );\n    }\n\n    /**\n     * @param {string} inputPath\n     * @returns {TSourceCodeData}\n     */\n    public readSourceCode (inputPath: string): TSourceCodeData {\n        if (SourceCodeReader.isFilePath(inputPath) && this.isValidFile(inputPath)) {\n            return this.readFile(inputPath);\n        }\n\n        if (SourceCodeReader.isDirectoryPath(inputPath) && this.isValidDirectory(inputPath)) {\n            return this.readDirectoryRecursive(inputPath);\n        }\n\n        const availableFilePaths: string = SourceCodeReader\n            .availableInputExtensions\n            .map((extension: string) => `\\`${extension}\\``)\n            .join(', ');\n\n        throw new ReferenceError(`Given input path must be a valid ${availableFilePaths} file or directory path`);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @param {IFileData[]} fileData\n     * @returns {IFileData[]}\n     */\n    private readDirectoryRecursive (directoryPath: string, fileData: IFileData[] = []): IFileData[] {\n        fs.readdirSync(directoryPath, JavaScriptObfuscatorCLI.encoding)\n            .forEach((fileName: string) => {\n                const filePath: string = `${directoryPath}/${fileName}`;\n\n                if (SourceCodeReader.isDirectoryPath(filePath) && this.isValidDirectory(filePath)) {\n                    fileData.push(...this.readDirectoryRecursive(filePath));\n                } else if (SourceCodeReader.isFilePath(filePath) && this.isValidFile(filePath)) {\n                    const content: string = this.readFile(filePath);\n\n                    fileData.push({ filePath, content });\n                }\n            });\n\n        return fileData;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {string}\n     */\n    private readFile (filePath: string): string {\n        SourceCodeReader.logFilePath(filePath);\n\n        return fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @returns {boolean}\n     */\n    private isValidDirectory (directoryPath: string): boolean {\n        return !SourceCodeReader.isExcludedPath(directoryPath, this.options.exclude);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private isValidFile (filePath: string): boolean {\n        return SourceCodeReader.availableInputExtensions.includes(path.extname(filePath))\n            && !filePath.includes(JavaScriptObfuscatorCLI.obfuscatedFilePrefix)\n            && !SourceCodeReader.isExcludedPath(filePath, this.options.exclude);\n    }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error('Cannot find module \"' + req + '\".');\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 72;","module.exports = require(\"mkdirp\");","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { TObject } from '../../types/TObject';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class CLIUtils {\n    /**\n     * @param {string} inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (inputPath: string): string {\n        return path\n            .normalize(inputPath)\n            .split('.')\n            .map((value: string, index: number) => {\n                return index === 0 ? `${value}${JavaScriptObfuscatorCLI.obfuscatedFilePrefix}` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param {string} outputCodePath\n     * @param {string} sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @param {string} configPath\n     * @returns {TObject}\n     */\n    public static getUserConfig (configPath: string): TObject {\n        let config: Object;\n\n        try {\n            config = require(configPath);\n        } catch {\n            try {\n                config = __non_webpack_require__(configPath);\n            } catch {\n                throw new ReferenceError('Given config path must be a valid `.js` or `.json` file path');\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * @param {string} outputPath\n     * @param {string} data\n     */\n    public static writeFile (outputPath: string, data: string): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: JavaScriptObfuscatorCLI.encoding\n        });\n    }\n}\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\nimport { TStringArrayEncoding } from '../../types/options/TStringArrayEncoding';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {string} value\n * @returns {TStringArrayEncoding}\n */\nexport const StringArrayEncodingSanitizer: TCLISanitizer <TStringArrayEncoding> = (value: string): TStringArrayEncoding => {\n    switch (value) {\n        case 'true':\n        case '1':\n        case StringArrayEncoding.Base64:\n            return true;\n\n        case StringArrayEncoding.Rc4:\n            return StringArrayEncoding.Rc4;\n\n        default:\n            return false;\n    }\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const SourceMapModeSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectSourceMapMode: boolean = Object\n        .keys(SourceMapMode)\n        .some((key: string): boolean => {\n            return SourceMapMode[<keyof typeof SourceMapMode>key] === value;\n        });\n\n    if (!isCorrectSourceMapMode) {\n        throw new ReferenceError('Invalid value of `--source-map-mode` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const ObfuscationTargetSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectTarget: boolean = Object\n        .keys(ObfuscationTarget)\n        .some((key: string): boolean => {\n            return ObfuscationTarget[<keyof typeof ObfuscationTarget>key] === value;\n        });\n\n    if (!isCorrectTarget) {\n        throw new ReferenceError('Invalid value of `--target` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const IdentifierNamesGeneratorSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectIdentifierNamesGenerator: boolean = Object\n        .keys(IdentifierNamesGenerator)\n        .some((key: string): boolean => {\n            return IdentifierNamesGenerator[<keyof typeof IdentifierNamesGenerator>key] === value;\n        });\n\n    if (!isCorrectIdentifierNamesGenerator) {\n        throw new ReferenceError('Invalid value of `--identifier-names-generator` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport const BooleanSanitizer: TCLISanitizer <boolean> = (value: string): boolean => {\n    return value === 'true' || value === '1';\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {string[]}\n */\nexport const ArraySanitizer: TCLISanitizer <string[]> = (value: string): string[] => {\n    if (/,$/.test(value)) {\n        throw new SyntaxError(`Multiple <list> values should be wrapped inside quotes: --option-name 'value1, value2'`);\n    }\n\n    return value.split(',').map((string: string) => string.trim());\n};\n","module.exports = require(\"commander\");","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TObfuscationResultFactory } from '../types/container/TObfuscationResultFactory';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\n\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\n\n@injectable()\nexport class SourceMapCorrector implements ISourceMapCorrector {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {TObfuscationResultFactory}\n     */\n    private readonly obfuscationResultFactory: TObfuscationResultFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {TObfuscationResultFactory} obfuscationResultFactory\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationResult) obfuscationResultFactory: TObfuscationResultFactory,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.obfuscationResultFactory = obfuscationResultFactory;\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {IObfuscationResult}\n     */\n    public correct (obfuscatedCode: string, sourceMap: string): IObfuscationResult {\n        return this.obfuscationResultFactory(\n            this.correctObfuscatedCode(obfuscatedCode, sourceMap),\n            sourceMap\n        );\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {string}\n     */\n    private correctObfuscatedCode (obfuscatedCode: string, sourceMap: string): string {\n        if (!sourceMap) {\n            return obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from './interfaces/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @param {string} sourceCode\n     */\n    constructor (sourceCode: string) {\n        this.sourceCode = sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { initializable } from './decorators/Initializable';\n\n@injectable()\nexport class ObfuscationResult implements IObfuscationResult {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n}\n","module.exports = require(\"events\");","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\nimport * as packageJson from 'pjson';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ISourceMapCorrector } from './interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        attachComment: true,\n        comment: true,\n        ecmaFeatures: {\n            experimentalObjectRestSpread: true\n        },\n        ecmaVersion: 9,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ISourceMapCorrector}\n     */\n    private readonly sourceMapCorrector: ISourceMapCorrector;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {ISourceMapCorrector} sourceMapCorrector\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.ISourceMapCorrector) sourceMapCorrector: ISourceMapCorrector,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.sourceMapCorrector = sourceMapCorrector;\n        this.randomGenerator = randomGenerator;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscationResult}\n     */\n    public obfuscate (sourceCode: string): IObfuscationResult {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, packageJson.version);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscationResult(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscationResult}\n     */\n    private getObfuscationResult (generatorOutput: IGeneratorOutput): IObfuscationResult {\n        return this.sourceMapCorrector.correct(\n            generatorOutput.code,\n            generatorOutput.map\n        );\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","module.exports = require(\"chance\");","module.exports = require(\"md5\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            '');\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public arrayRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public arrayRotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public arrayShuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.arrayRotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isNodeWithComments(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     *\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node {\n        if (node.leadingComments) {\n            node.leadingComments = this.transformComments(node.leadingComments);\n        }\n\n        if (node.trailingComments) {\n            node.trailingComments = this.transformComments(node.trailingComments);\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord))\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n});\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFromUrl(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { ValidationError } from 'class-validator';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} validationErrors\n     * @returns {string}\n     */\n    public static format (validationErrors: ValidationError[]): string {\n        const errorsArray: string[] = [];\n\n        for (const error of validationErrors) {\n            errorsArray.push(ValidationErrorsFormatter.formatError(error));\n        }\n\n        return errorsArray.join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} validationError\n     * @returns {string}\n     */\n    private static formatError (validationError: ValidationError): string {\n        const constraints: {[type: string]: string} = validationError.constraints;\n\n        let errorString: string = `\\`${validationError.property}\\` errors:\\n`;\n\n        Object\n            .keys(constraints)\n            .forEach((constraint: string) => {\n                errorString += `    - ${constraints[constraint]}\\n`;\n            });\n\n        return errorString;\n    }\n}\n","module.exports = require(\"class-validator\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(variableDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? blockScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, scopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, nodeIdentifier);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, nodeIdentifier);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, nodeIdentifier);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {Node} scopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        scopeNode: ESTree.Node,\n        nodeIdentifier: number\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined = this.replaceableIdentifiers.get(scopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, nodeIdentifier);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {NodeGuards} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer.replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] = storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = Utils.decToHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!Utils.isCeilNumber(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${Utils.decToHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer)\n                    .replace(<boolean>literalNode.value);\n\n            case 'number':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer)\n                    .replace(<number>literalNode.value);\n\n            case 'string':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer)\n                    .replace(<string>literalNode.value);\n\n            default:\n                return literalNode;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeLabeledStatementName(labeledStatementNode, nodeIdentifier);\n        this.replaceLabeledStatementName(labeledStatementNode, nodeIdentifier);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {number} nodeIdentifier\n     */\n    private storeLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, nodeIdentifier);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(importDeclarationNode)[0];\n\n        this.storeImportSpecifierNames(importDeclarationNode, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode, nodeIdentifier);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDefaultSpecifier | ImportNamespaceSpecifier} importDeclarationNode\n     * @param {number} nodeIdentifier\n     */\n    private storeImportSpecifierNames (importDeclarationNode: ESTree.ImportDeclaration, nodeIdentifier: number): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, nodeIdentifier);\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] = <ESTree.Identifier[]>this.replaceableIdentifiers.get(blockScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, nodeIdentifier);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeFunctionParams(functionNode, nodeIdentifier);\n        this.replaceFunctionParams(functionNode, nodeIdentifier);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {number} nodeIdentifier\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                estraverse.traverse(paramsNode, {\n                    enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                        if (NodeGuards.isPropertyNode(paramsNode)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.left.name, nodeIdentifier);\n\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.name, nodeIdentifier);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private addIdentifiersToIgnoredIdentifierNamesSet (\n        properties: ESTree.Property[],\n        ignoredIdentifierNamesSet: Set<string>\n    ): void {\n        properties.forEach((property: ESTree.Property) => {\n            if (!property.key || !NodeGuards.isIdentifierNode(property.key)) {\n                return;\n            }\n\n            ignoredIdentifierNamesSet.add(property.key.name);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        const ignoredIdentifierNamesSet: Set<string> = new Set();\n\n        const replaceVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (NodeGuards.isObjectPatternNode(node)) {\n                    this.addIdentifiersToIgnoredIdentifierNamesSet(node.properties, ignoredIdentifierNamesSet);\n                }\n\n                if (\n                    parentNode &&\n                    NodeGuards.isReplaceableIdentifierNode(node, parentNode) &&\n                    !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer.replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => estraverse.replace(paramsNode, replaceVisitor));\n\n        estraverse.replace(functionNode.body, replaceVisitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(functionDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, blockScopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode, nodeIdentifier);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, nodeIdentifier);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        nodeIdentifier: number\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined = this.replaceableIdentifiers.get(blockScopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, nodeIdentifier);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] = storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(classDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode, nodeIdentifier);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, nodeIdentifier);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] = <ESTree.Identifier[]>this.replaceableIdentifiers.get(blockScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, nodeIdentifier);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeCatchClauseParam(catchClauseNode, nodeIdentifier);\n        this.replaceCatchClauseParam(catchClauseNode, nodeIdentifier);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {number} nodeIdentifier\n     */\n    private storeCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly namesMap: Map<string, string> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {number} nodeIdentifier\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, nodeIdentifier: number): ESTree.Identifier {\n        const mapKey: string = `${nodeValue}-${String(nodeIdentifier)}`;\n\n        if (this.namesMap.has(mapKey)) {\n            nodeValue = <string>this.namesMap.get(mapKey);\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {number} nodeIdentifier\n     */\n    public storeGlobalName (nodeName: string, nodeIdentifier: number): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        this.namesMap.set(`${nodeName}-${String(nodeIdentifier)}`, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {number} nodeIdentifier\n     */\n    public storeLocalName (nodeName: string, nodeIdentifier: number): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        this.namesMap.set(`${nodeName}-${String(nodeIdentifier)}`, identifierName);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = Utils.decToHex(randomInteger);\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate();\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const identifierName: string = this.generate();\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","export enum JSFuck {\n    False = '![]',\n    True = '!![]',\n\n    a = '(false+\"\")[1]',\n    b = '([][\"entries\"]()+\"\")[2]',\n    c = '([][\"fill\"]+\"\")[3]',\n    d = '(undefined+\"\")[2]',\n    e = '(true+\"\")[3]',\n    f = '(false+\"\")[0]',\n    g = '(false+[0]+String)[20]',\n    h = '(+(101))[\"toString\"](21)[1]',\n    i = '([false]+undefined)[10]',\n    j = '([][\"entries\"]()+\"\")[3]',\n    k = '(+(20))[\"toString\"](21)',\n    l = '(false+\"\")[2]',\n    m = '(Number+\"\")[11]',\n    n = '(undefined+\"\")[1]',\n    o = '(true+[][\"fill\"])[10]',\n    p = '(+(211))[\"toString\"](31)[1]',\n    q = '(+(212))[\"toString\"](31)[1]',\n    r = '(true+\"\")[1]',\n    s = '(false+\"\")[3]',\n    t = '(true+\"\")[0]',\n    u = '(undefined+\"\")[0]',\n    v = '(+(31))[\"toString\"](32)',\n    w = '(+(32))[\"toString\"](33)',\n    x = '(+(101))[\"toString\"](34)[1]',\n    y = '(NaN+[Infinity])[10]',\n    z = '(+(35))[\"toString\"](36)',\n\n    A = '(+[]+Array)[10]',\n    B = '(+[]+Boolean)[10]',\n    C = 'Function(\"return escape\")()((\"\")[\"italics\"]())[2]',\n    D = 'Function(\"return escape\")()([][\"fill\"])[\"slice\"](\"-1\")',\n    E = '(RegExp+\"\")[12]',\n    F = '(+[]+Function)[10]',\n    G = '(false+Function(\"return Date\")()())[30]',\n    H = '\\'H\\'',\n    I = '(Infinity+\"\")[0]',\n    J = '\\'J\\'',\n    K = '\\'K\\'',\n    L = '\\'L\\'',\n    M = '(true+Function(\"return Date\")()())[30]',\n    N = '(NaN+\"\")[0]',\n    O = '(NaN+Function(\"return{}\")())[11]',\n    P = '\\'P\\'',\n    Q = '\\'Q\\'',\n    R = '(+[]+RegExp)[10]',\n    S = '(+[]+String)[10]',\n    T = '(NaN+Function(\"return Date\")()())[30]',\n    U = '(NaN+Function(\"return{}\")()[\"toString\"][\"call\"]())[11]',\n    V = '\\'V\\'',\n    W = '\\'W\\'',\n    X = '\\'X\\'',\n    Y = '\\'Y\\'',\n    Z = '\\'Z\\'',\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: Utils.decToHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `е` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indеxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indеxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n                        \n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n            \n            if ((!document && !domain) || (!that[document] && !that[document][domain])) {\n                return;\n            }\n            \n            var currentDomain = that[document][domain];\n\n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                    \n                    break;\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode([\n            NodeFactory.variableDeclaratorNode(\n                NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                NodeFactory.objectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode([\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(controllerIdentifierName),\n                    NodeFactory.callExpressionNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.literalNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            NodeFactory.identifierNode('split')\n                        ),\n                        [\n                            NodeFactory.literalNode('|')\n                        ]\n                    )\n                ),\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(indexIdentifierName),\n                    NodeFactory.literalNode(0)\n                )\n            ]),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prependNode(blockScopeNode, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNode(blockScopeNode, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = blockScopeNode.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            return root;\n        }\n\n        return nodes[0];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (property.computed || !property.key) {\n                    return;\n                }\n\n                if (property.shorthand) {\n                    property.shorthand = false;\n                }\n\n                if (NodeGuards.isIdentifierNode(property.key)) {\n                    property.key = NodeFactory.literalNode(property.key.name);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<VariableDeclarator, TNodeWithScope>}\n     */\n    private readonly cachedScopeNodesMap: Map <ESTree.VariableDeclarator, TNodeWithScope> = new Map();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {ExpressionStatement[]} expressionStatements\n     * @param {Node} variableDeclarator\n     */\n    private static appendExpressionStatements (\n        scopeNode: TNodeWithScope,\n        expressionStatements: ESTree.ExpressionStatement[],\n        variableDeclarator: ESTree.Node\n    ): void {\n        const variableDeclaration: ESTree.Node | undefined = variableDeclarator.parentNode;\n\n        if (!variableDeclaration || !NodeGuards.isVariableDeclarationNode(variableDeclaration)) {\n            throw new Error('Cannot find variable declaration for variable declarator');\n        }\n\n        NodeAppender.insertNodeAfter(scopeNode, expressionStatements, variableDeclaration);\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {number[]} removablePropertyIds\n     * @returns {Property[]}\n     */\n    private static filterObjectExpressionProperties (properties: ESTree.Property[], removablePropertyIds: number[]): ESTree.Property[] {\n        return properties.filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    private static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        } else if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Expression | Pattern} propertyValueNode\n     * @returns {boolean}\n     */\n    private static isValidPropertyValueNode (propertyValueNode: ESTree.Expression | ESTree.Pattern): propertyValueNode is ESTree.Expression {\n        return !NodeGuards.isObjectPatternNode(propertyValueNode)\n        && !NodeGuards.isArrayPatternNode(propertyValueNode)\n        && !NodeGuards.isAssignmentPatternNode(propertyValueNode)\n        && !NodeGuards.isRestElementNode(propertyValueNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            this.options.transformObjectKeys\n                            && parentNode\n                            && NodeGuards.isObjectExpressionNode(node)\n                            && NodeGuards.isVariableDeclaratorNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {NodeGuards} variableDeclarator\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, variableDeclarator: ESTree.VariableDeclarator): ESTree.Node {\n        // should pass only Expression nodes as MemberExpression.object value\n        if (!NodeGuards.isIdentifierNode(variableDeclarator.id)) {\n            return objectExpressionNode;\n        }\n\n        const scopeNode: TNodeWithScope | null = NodeUtils.getScopeOfNode(variableDeclarator);\n\n        if (!scopeNode || !NodeGuards.isNodeHasScope(scopeNode)) {\n            return objectExpressionNode;\n        }\n\n        this.cachedScopeNodesMap.set(variableDeclarator, scopeNode);\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            variableDeclarator.id,\n            variableDeclarator\n        );\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionObject\n     * @param {VariableDeclarator} variableDeclarator\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    private extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionObject: ESTree.Expression,\n        variableDeclarator: ESTree.VariableDeclarator\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (!ObjectExpressionKeysTransformer.isValidPropertyValueNode(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = ObjectExpressionKeysTransformer.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionObject, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode, variableDeclarator);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionObjectNode\n     * @param {VariableDeclarator} variableDeclarator\n     * @returns {Node}\n     */\n    private transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionObjectNode: ESTree.Expression,\n        variableDeclarator: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n\n        if (!properties.length) {\n            return objectExpressionNode;\n        }\n\n        const scopeNode: TNodeWithScope | undefined = this.cachedScopeNodesMap.get(variableDeclarator);\n\n        if (!scopeNode) {\n            return objectExpressionNode;\n        }\n\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionObjectNode, variableDeclarator);\n\n        objectExpressionNode.properties = ObjectExpressionKeysTransformer\n            .filterObjectExpressionProperties(properties, removablePropertyIds);\n        ObjectExpressionKeysTransformer\n            .appendExpressionStatements(scopeNode, expressionStatements, variableDeclarator);\n\n        return objectExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(methodDefinitionNode.key.name);\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithBlockScope>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithBlockScope> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithBlockScope = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prependNode(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithBlockScope): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                hostNode.body.shift();\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithBlockScope}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithBlockScope {\n        const blockScopesOfNode: TNodeWithBlockScope[] = NodeUtils.getBlockScopesOfNode(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const blockScopeOfBlockStatementNode: TNodeWithBlockScope = NodeUtils\n            .getBlockScopesOfNode(blockStatementNode)[0];\n\n        return blockScopeOfBlockStatementNode.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                let clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                NodeUtils.parentizeNode(clonedBlockStatementNode, clonedBlockStatementNode);\n                clonedBlockStatementNode = this.transformersRunner.transform(\n                    clonedBlockStatementNode,\n                    DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n                    TransformationStage.Obfuscating\n                );\n\n                this.collectedBlockStatements.push(clonedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/reflect/has-metadata\");","module.exports = require(\"@babel/runtime/core-js/reflect/define-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-names\");","module.exports = require(\"@babel/runtime/core-js/reflect/get-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-descriptor\");","module.exports = require(\"@babel/runtime/core-js/object/define-property\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static blockStatementHasProhibitedStatements (blockStatementNode: ESTree.BlockStatement): boolean {\n        return blockStatementNode.body.some((statement: ESTree.Statement) => {\n            const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(statement)\n                || NodeGuards.isContinueStatementNode(statement);\n            const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(statement)\n                && (statement.kind === 'const' || statement.kind === 'let');\n            const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(statement);\n\n            return NodeGuards.isFunctionDeclarationNode(statement)\n                || isBreakOrContinueStatement\n                || isVariableDeclarationWithLetOrConstKind\n                || isClassDeclaration;\n        });\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (\n                    NodeGuards.isBlockStatementNode(node)\n                    && BlockStatementControlFlowTransformer.blockStatementHasProhibitedStatements(node)\n                ) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.arrayRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.arrayShuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeUtils.getBlockScopesOfNode(node)[0]) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // node transformers factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","module.exports = require(\"reflect-metadata\");","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscatorFacade';\n\nmodule.exports = JavaScriptObfuscator;\n"],"sourceRoot":""}